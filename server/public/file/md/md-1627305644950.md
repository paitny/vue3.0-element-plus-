# 运算符

## 1.算术运算符

`+ - * / % ++ -- **`

```js
//注意 + 号在不同前后文里面的不同作用：
let a = 1 + 2; //结果：3     算术运算
let b = 1 + "2"; //结果："12"     拼接运算，+号两边任一边有字符串，+号就是拼接的作用
let c = +"1"; //结果：1   +号前面啥数据都没有时，类似于Number()的功能，将数据转换为数字，转不了得到NaN
```

```js
// 注意 - 号在不同前后文里面的不同作用：
let a = 2 - 1; //结果1  算术运算
let b = "2" - 1; //结果1  当成数字来运算
let c = -1; //结果-1  负号
let d = -"1"; //结果-1   同+号前面都没有时情况一样，只不过最终结果带上 负号 -
```

前置自增自减 和 后置自增自减

```js
//如果只看最终结果，没有区别
let x = 5;
//x ++; alert(x); //6
++ x; alert(x); //6
```

```js
//看中间过程，是有区别的
let x = 5;
//let y = x ++; alert(y); alert(x); // 5 6
let y = ++ x; 

alert(y); alert(x); // 6 6
```

### 隐式类型转换

不同的类型的数据进行运算时会进行隐式类型转换。需要掌握的有：

```js
1 + "2" === "12"  //和字符串进行 + 运算，会转换成字符串再运算

"3" - "2" === 1  //进行减 乘 除 取模 乘方运算时，会转换成数字再运算

let a = "3";
a ++; //++ --运算会转换成数字再+1 -1，最后得到数字结果
```

## 2.赋值运算符

`=  +=  -=  *=  /=  %=`

`x += 10;` 相当于 `x = x + 10;` ，其他同理。

## 3.比较运算符

`==   ===   !=   !===   >   <   >=   <=`

运算完后，会得到一个布尔值。

`==`判断值等不等，`===`判断类型和值等不等。

字符串再比较大小时，是按位比较各自的编码。`"3">"20"`得到`true`。

对象在做相等判断时，比较的是内存地址。

## 4.逻辑运算符

`&& || !`

逻辑运算符也是通常用来做流程控制的。

`!`的结果始终是一个布尔值。

## 5.逗号操作符

`,` 使用，代表语句还没结束，或者在一条语句里面执行多个事情

```js
let a = 10,b = 20,c = 30; //多个定义

let x = (1,2,3,4,5); //x值最终为5
```

## 6. 运算符优先级

[运算符优先级](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin)

## √. 案例or作业

- [商品价格计算](http://static.zzhitong.com/lesson-files/javascript/code/4-1.html)

- [切换按钮背景色](http://static.zzhitong.com/lesson-files/javascript/code/4-2.html)

- [评论提交](http://static.zzhitong.com/lesson-files/javascript/code/4-3.html)

## 拓展知识（不用掌握）

### 位运算

位运算直接对内存中表示数据的位进行操作，所以运算效率是最高的。

位运算时会将数值转换为32位整型来进行运算，所以位运算遇到小数时，直接处理掉小数部分当成整数来运算。并且*要是一个数的二进制表示超过32位，或者运算完后超过32位，那么就会出问题。所以不是所有的情况都适用位运算*。

32位中，前31位表示数值，第32位表示符号，例如：**3** 的32位表示为：`00000000 00000000 00000000 00000011`。（PS：短除法求二进制）。

负数会以**二进制补码**的形式来表示，规则是：

```js
//以 -3 为例子

//第一步：取负数对应的正数的二进制码，例子中取 3 的二进制码
00000000 00000000 00000000 00000011 //3的二进制码

//第二步：取得到的二进制码的反码，0变1  1变0
11111111 11111111 11111111 11111100 //二进制反码

//第三步：反码加1
11111111 11111111 11111111 11111101 //得到-3的二进制表示
```

位运算操作符：按位非`~` 、按位与`&`、按位或`|`、按位异或`^`、左移`<<`、无符号右移`>>>`、有符号右移`>>`。

- **~ 按位非**

每一位取反，例：

```js
let a = 12;
let b = ~a;

// 12的二进制表示：     00000000 00000000 00000000 00001100
// 按位非得到最终结果： 11111111 11111111 11111111 11110011  

//因为 第32位是1，代表负数，那这个负数是多少呢？按照上面的办法我们可以反推回来：
//负数码减-1：         11111111 11111111 11111111 11110010
//结果取反码：         00000000 00000000 00000000 00001101
//表示的正数是：13，所以该负数为  -13

alert(b); //验证一下
```

所以按位非的结果为 该数负数减1， `~12 === -13` `~-5 === 4`

- **& 按位与**

与是两个数之间的操作，两个数每一位的值 1 1 得1   1 0得0   0 1得0  0 0得0，例：

```js
let a = 11 & 4;

//11的二进制  00000000 00000000 00000000 00001011
//4 的二进制  00000000 00000000 00000000 00000100
//按位与      00000000 00000000 00000000 00000000
//结果为 0

alert( a ); //验证一下
```

- **| 按位或    ^ 按位异或**

这就和上面一个道理了，或都应该能理解 11得1  10得1   01得1  00得0，

异或：11得0   10得1    01得1   00得0   

- **<< 左移**

二进制码左移几位，右边的空位补0

```js
let a = 4 << 2;

//4的二进制码： 00000000 00000000 00000000 00000100
//左移2位：  00 00000000 00000000 00000000 000100    //左边超过32的就不用管了，右边少于8位的补0    
//得到：        00000000 00000000 00000000 00010000  // 16

alert(a); //验证一下
```

左移是*不会改变符号位*的，相当于原来的数乘以 2的几次方。

- **>>> 无符号右移    >> 有符号右移**

有符号右移：不动符号位，二进制码右移，左侧补0，原理和上述一样。

无符号右移：移动所有位包括符号位，整体右移，左侧补0，所以如果负数进行无符号右移，会得到一个很蛋疼的数。

- 位运算的运用

左移右移来进行相对于 2的乘方 运算。

强制取整，位运算直接会舍弃小数，例如：`let a = 12.12 | 0;`，直接舍弃小数位，并且或上0不会影响整数位。

判断奇偶，奇数 & 1 一定是 1            偶数 & 1一定是 0

……